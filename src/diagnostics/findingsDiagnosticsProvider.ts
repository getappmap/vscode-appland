import * as vscode from 'vscode';
import { ResolvedFinding } from '../services/resolvedFinding';

type DiagnosticWithProblemLocation = {
  diagnostic: vscode.Diagnostic;
  problemUri: vscode.Uri;
};

export default class FindingsDiagnosticsProvider {
  diagnosticsCollection: vscode.DiagnosticCollection;
  findingsBySourceUri: Record<string, ResolvedFinding[]> = {};
  diagnosticsBySourceUri: Record<string, DiagnosticWithProblemLocation[]> = {};

  constructor(context: vscode.ExtensionContext) {
    this.diagnosticsCollection = vscode.languages.createDiagnosticCollection('appmap-findings');
    context.subscriptions.push(this.diagnosticsCollection);
  }

  // Submits new findings from a findings file (a JSON file generated by the AppMap scanner).
  // Diagnostics are organized by the problem location, not by the JSON file in which they are listed.
  // So, when a findings file is updated, all Diagnostics that are affected by the findings in that file
  // need to be re-generated. That is, any findings that were in a previous version of the file should be removed
  // from the list of diagnostics fro their problem location, and new findings added.
  updateFindings(sourceUri: vscode.Uri, findings: ResolvedFinding[]): void {
    // updatedLocations is all the problem locations whose dignostics need to be replaced.
    const updatedProblemUriStrings = new Set<string>();
    (this.findingsBySourceUri[sourceUri.toString()] || []).forEach((finding) => {
      if (!finding.problemLocation) return;
      updatedProblemUriStrings.add(finding.problemLocation?.uri.toString());
    });

    this.diagnosticsBySourceUri[sourceUri.toString()] = [];
    this.findingsBySourceUri[sourceUri.toString()] = findings;

    // Build a diagnostic for each finding.
    findings.map((finding) => {
      if (!finding.problemLocation) return;

      const relatedInformation = finding.appMapUri
        ? [
            new vscode.DiagnosticRelatedInformation(
              new vscode.Location(finding.appMapUri, new vscode.Position(0, 0)),
              'Open AppMap'
            ),
          ]
        : [];

      const problemUri = finding.problemLocation.uri;
      updatedProblemUriStrings.add(problemUri.toString());
      const diagnostic = {
        message: finding.finding.message,
        source: 'appmap',
        range: finding.problemLocation.range,
        relatedInformation,
        severity: vscode.DiagnosticSeverity.Warning, // TODO: Set severity more specifically
        code: {
          value: finding.finding.ruleId,
          target: vscode.Uri.parse(
            `https://appland.com/docs/analysis/rules-reference#${finding.finding.ruleId}`
          ),
        },
      } as vscode.Diagnostic;
      this.diagnosticsBySourceUri[sourceUri.toString()].push({
        diagnostic,
        problemUri,
      });
    });

    // Now update the diagnostics collection for the problemLocation of each finding
    [...updatedProblemUriStrings].forEach((problemUriString: string) => {
      const diagnostics = Object.values(this.diagnosticsBySourceUri)
        .map((diagnostics) =>
          diagnostics.filter((diagnostic) => diagnostic.problemUri.toString() === problemUriString)
        )
        .flat()
        .map((diagnosticWithProblemLocation) => diagnosticWithProblemLocation.diagnostic);

      this.diagnosticsCollection.set(
        vscode.Uri.parse(problemUriString, true),
        diagnostics.sort((a, b) => a.message.localeCompare(b.message))
      );
    });
  }
}
